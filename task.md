Проект Heroes посвящён разработке алгоритмов для пошаговой стратегии с боевой системой. В итоговом задании вам предстоит реализовать ключевые алгоритмы, которые отвечают за генерацию армии противника, симуляцию пошагового боя, определение доступных целей для атаки и поиск кратчайшего пути между юнитами.

Цель проекта — применить и закрепить знания по алгоритмам и структурам данных, разработав эффективные решения для игровых механик.

Особое внимание будет уделено:

алгоритмической эффективности реализованных решений (оптимальная сложность работы каждого метода);
корректной реализации логики боя (очерёдность ходов, устранение выбывших юнитов, корректное завершение боя);
оптимальному подбору состава армии противника по заданным ограничениям;
поиску кратчайшего маршрута на игровом поле с учётом препятствий (других юнитов).
Итоговый проект позволит закрепить навыки анализа сложности алгоритмов и работы со структурами данных и продемонстрировать умение применять классические алгоритмы (например, поиск пути в графе) в решении практических задач.

Что нужно сделать

Проект состоит из нескольких модулей, которые организованы в виде Gradle-проектов:

heroes — основной модуль игры. Отвечает за интерфейс, визуализацию и проведение боя, используя алгоритмы, реализованные студентом. Этот модуль подключает библиотеку heroes_task_lib и загружает алгоритмы из модуля задачи.
heroes_task — модуль задания студента, в котором находятся заготовки реализаций четырёх требуемых алгоритмов. Студент должен имплементировать методы в этом модуле согласно спецификации. Модуль подключает библиотеку heroes_task_lib как зависимость.
heroes_task_lib — библиотека (модуль) игры, содержащая основные классы и интерфейсы, необходимые для работы проекта. В том числе здесь определены интерфейсы GeneratePreset, SimulateBattle, SuitableForAttackUnitsFinder и UnitTargetPathFinder, методы которых предстоит реализовать.
Все модули используют Gradle в качестве системы сборки — это обеспечивает совместимость и удобство подключения библиотеки к проекту задания.

Как запустить проект
Распакуйте архив heroes.rar в любом удобном месте. По пути архива с распакованной игрой не должно быть кириллицы. Запустите игру одним из двух способов:

Убедитесь, что у вас стоит Java, и дважды щёлкните левой кнопкой мыши по файлу Heroes Battle-1.0.0.jar.
Откройте powershell в папке, в которой распаковали игру, и выполните команду java -jar "Heroes Battle-1.0.0.jar". Этот вариант предпочтительнее, так как вы сможете видеть лог работы игры в терминале.
Чтобы проверить ваше решение, поместите собранный jar вашего проекта с реализованными интерфейсами в папку heroes\jars, заменив лежащий там obf.jar. Он автоматически подхватится игрой при запуске, и она будет использовать реализацию ваших алгоритмов.

Требования к реализации
В проекте библиотеки игры heroes_task_lib определено четыре интерфейса, методы которых вам предстоит имплементировать в проекте heroes_task согласно документации. Это интерфейсы GeneratePreset, SimulateBattle, SuitableForAttackUnitsFinder и UnitTargetPathFinder.

Они отвечают за реализацию следующего логического функционала внутри основного проекта игры:

GeneratePreset содержит в себе метод Army generate(List<Unit> unitList, int maxPoints), который отвечает за генерацию пресета армии противника.
SimulateBattle содержит в себе метод void simulate(Army playerArmy, Army computerArmy) throws InterruptedException; и отвечает за осуществление симуляции боя.
SuitableForAttackUnitsFinder содержит в себе метод List<Unit> getSuitableUnits(List<List<Unit>> unitsByRow, boolean isLeftArmyTarget); и отвечает за создание перечня подходящих для атаки юнитов.
UnitTargetPathFinder содержит в себе метод List<Edge> getTargetPath(Unit attackUnit, Unit targetUnit, List<Unit> existingUnitList); и отвечает за поиск наикратчайшего пути между атакующим и атакуемым юнитом.
Вам дан проект heroes_task с уже подключённой библиотекой heroes_task_lib и созданными заготовками имплементации для каждого интерфейса.

Метод generate интерфейса GeneratePreset
Метод формирует пресет армии компьютера, то есть максимально эффективный по соотношению атаки к стоимости в первую очередь и соотношению здоровья к стоимости набора юнитов разного типа таким образом, чтобы при этом соблюдалось ограничение в 11 юнитов каждого типа.

Оцениваться будет:

соблюдение ограничений;
результат сражения армии компьютера с армией, набранной пользователем;
алгоритмическая сложность алгоритма.
Цель данного метода — создать армию компьютера.

Метод имеет следующую сигнатуру:

Army generate(List<Unit> unitList, int maxPoints)
В нём:

Параметр unitList — список юнитов, содержит объект юнита каждого типа. На его основе происходит заполнение армии компьютера. В данный момент существует четыре типа юнитов — лучник, всадник, мечник и копейщик.
Параметр maxPoints — максимальное число очков в сумме для всех юнитов армии, в данный момент — 1500.
Возвращаемое значение — возвращает объект армии компьютера со списком юнитов внутри неё.
Алгоритмическая сложность должна быть  или лучше, где

 — общее число типов юнитов;
 — максимальное число юнитов в армии.
Метод simulate интерфейса SimulateBattle
Этот метод осуществляет симуляцию боя между армией игрока и армией компьютера. Цель метода — провести бой, следуя установленным правилам.

Симуляция происходит следующим образом:

На каждом раунде юниты сортируются по убыванию значения атаки, чтобы первыми ходили самые сильные.
Пока в обеих армиях есть живые юниты, они атакуют друг друга по очереди.
Если у одной из армий заканчиваются юниты, она ожидает завершения ходов оставшихся юнитов противника.
Когда все юниты походили, раунд завершается, и начинается следующий.

Юниты, которые погибли (значение поля isAlive — false) и ещё не походили, исключаются из очередей в момент их смерти, и очереди хода пересчитываются.

Если количество юнитов в армиях становится разным из-за потерь, очерёдность ходов может измениться.

Юниты атакуют друг друга с помощью метода unit.getProgram().attack(), который возвращает цель атаки (юнит противника) или null, если цель не найдена.

После каждой атаки необходимо вывести лог с помощью метода printBattleLog.printBattleLog(unit, target), где unit — атакующий юнит, а target — цель атаки.

Симуляция завершается, когда у одной из армий не остаётся живых юнитов, способных сделать ход.
Метод имеет следующую сигнатуру:

void simulate(Army playerArmy, Army computerArmy)
Здесь:

Параметр playerArmy — объект армии игрока, содержащий список её юнитов.
Параметр computerArmy — объект армии компьютера, содержащий список её юнитов.
Алгоритмическая сложность данного алгоритма должна быть  или лучше, если принять, что метод атаки юнита работает за , где  — общее количество юнитов в армии.

Метод getSuitableUnits интерфейса SuitableForAttackUnitsFinder
Метод определяет список юнитов, подходящих для атаки, для атакующего юнита одной из армий. Цель метода — исключить ненужные попытки найти кратчайший путь между юнитами, которые не могут атаковать друг друга.

Подходящий юнит для атаки для атакующей армии компьютера — это юнит армии игрока, который не закрыт справа (по координате y) другим юнитом армии игрока.

Подходящий юнит для атаки для атакующей армии игрока — это юнит армии компьютера, который не закрыт слева (по координате y) другим юнитом армии компьютера. То есть слева от юнита в соседней клетке находится другой юнит.

Метод имеет следующую сигнатуру:

public List<Unit> getSuitableUnits(List<List<Unit>> unitsByRow, boolean isLeftArmyTarget)
В нём

Параметр unitsByRow — трёхслойный массив юнитов противника. Для юнита из атакующей армии компьютера эти юниты находятся на координатах 24..26 по оси x. Для армии игрока они располагаются на координатах 0..2 по оси x (фактически, это юниты армии компьютера).
Параметр isLeftArmyTarget — параметр, который указывает, юниты какой армии подвергаются атаке. Если значение true, то атаке подвергаются юниты армии компьютера (левая армия); если false — юниты армии игрока (правая армия).
Возвращаемое значение — метод возвращает список юнитов, подходящих для атаки, для юнита атакующей армии.
Алгоритмическая сложность данного метода должна быть  или лучше, что означает линейную сложность на двумерной плоскости, где  — количество юнитов в ряду, а  — количество рядов. Так как количество рядов фиксировано и равно трём, алгоритм фактически должен иметь линейную сложность  или лучше.

Метод getTargetPath интерфейса UnitTargetPathFinder
Метод определяет кратчайший маршрут между атакующим и атакуемым юнитом и возвращает его в виде списка объектов, содержащих координаты каждой точки данного кратчайшего пути.

Цель данного метода — найти кратчайший путь между атакующим и атакуемым юнитами. То есть для атакующего юнита с координатами  и  и атакуемого юнита  и  результатом станет список [Edge(1, 2), Edge (1, 1), Edge (1,0)].

Для определения кратчайшего пути рекомендуем использовать один из алгоритмов теории графов.

Метод имеет следующую сигнатуру:

List<Edge> getTargetPath(Unit attackUnit, Unit targetUnit, List<Unit> existingUnitList)
Здесь:

Параметр attackUnit — юнит, который атакует.
Параметр targetUnit — юнит, который подвергается атаке.
Параметр existingUnitList — список всех существующих юнитов на данный момент.
Возвращаемое значение — список объектов Edge, то есть координат клеток пути от атакующего юнита до атакуемого юнита включительно. Если маршрут не найден — возвращает пустой список.
Алгоритмическая сложность данного метода составляет  или лучше, где:

WIDTH — ширина игрового поля (27);
HEIGHT — высота игрового поля (21).
Алгоритм, представленный в коде, использует один из алгоритмов теории графов для нахождения кратчайшего пути на поле с препятствиями, где некоторые клетки заняты юнитами. Основные шаги включают инициализацию структуры данных для хранения расстояний, обработку соседних клеток и определение пути. Допускается движение по диагонали.

Этапы выполнения задания
Реализуйте все четыре метода в проекте heroes_task, затем соберите ваш проект и поместите полученный jar в папку jars игры, которую вы распаковали из архива heroes.rar.

Этап	Название этапа	Суть	Баллы
1	Подготовка	
Внимательно изучите постановку задачи и описание алгоритмов, которые необходимо реализовать.
Распакуйте архивы: heroes и heroes_task.rar.
Откройте проект heroes_task.rar в IDE, найдите в директории com.heroes_task.programs четыре заготовки для имплементации интерфейсов библиотеки history_task_lib откройте их
0
2	Реализация метода getSuitableUnits интерфейса SuitableForAttackUnitsFinder	
Откройте класс SuitableForAttackUnitsFinderImpl и найдите там переопределённый метод getSuitableUnits.
Напишите его реализацию.
Проверьте, что метод работает корректно, с этой целью к проекту уже подключены библиотеки для написания юнит-тестов.
Рассчитайте алгоритмическую сложность вашей версии алгоритма и составьте её доказательство, сначала рассчитав сложность для каждого этапа алгоритма, а затем итоговую сложность. Убедитесь, что ваша сложность такая же или лучше, чем в документации
5
3	Реализация метода generate интерфейса GeneratePreset
Откройте класс GeneratePresetImpl и найдите там переопределённый метод generate.
Напишите его реализацию.
Проверьте, что метод работает корректно, с этой целью к проекту уже подключены библиотеки для написания юнит-тестов.
Рассчитайте алгоритмическую сложность вашей версии алгоритма и составьте её доказательство, сначала рассчитав сложность для каждого этапа алгоритма, а затем итоговую сложность. Убедитесь, что ваша сложность такая же или лучше, чем в документации
10
4	Реализация метода getTargetPath интерфейса UnitTargetPathFinder	
Откройте класс UnitTargetPathFinderImpl и найдите там переопределённый метод getTargetPath.
Напишите его реализацию.
Проверьте, что метод работает корректно, с этой целью к проекту уже подключены библиотеки для написания юнит-тестов.
Рассчитайте алгоритмическую сложность вашей версии алгоритма и составьте её доказательство, сначала рассчитав сложность для каждого этапа алгоритма, а затем итоговую сложность. Убедитесь, что ваша сложность такая же или лучше, чем в документации
10
5	Реализация метода simulate интерфейса SimulateBattle	
Откройте класс SimulateBattleImpl и найдите там переопределённый метод simulate. Напишите его реализацию.
Проверьте, что метод работает корректно, с этой целью к проекту уже подключены библиотеки для написания юнит-тестов.
Рассчитайте алгоритмическую сложность вашей версии алгоритма и составьте её доказательство, сначала рассчитав сложность для каждого этапа алгоритма, а затем итоговую сложность. Убедитесь, что ваша сложность такая же или лучше, чем в документации
5
6	Сборка проекта	
Убедитесь, что реализованы все четыре метода.
Настроить артефакт в IntelliJ IDEA. Это можно сделать, открыв меню File → Project Structure → Artifacts. Нажмите на кнопку «плюс» и выберите JAR из выпадающего списка. Затем — опцию From modules with dependencies.
После завершения всех настроек можно собрать артефакт, выбрав Build → Build Artifacts и ваш артефакт для сборки.
После выполнения этих шагов в указанном каталоге должен появиться JAR-файл, содержащий все необходимые файлы для работы приложения. Если при запуске полученного JAR-файла возникают проблемы, возможно, стоит проверить пути к библиотекам и классам в настройках артефакта.
Переместить полученный JAR-файл из директории out/artifacts/heroes_student_task_jar в директорию jars распакованной игры, удалив из него предыдущий JAR-файл
0
7	Запуск игры	
Запустите игру одним из двух способов, описанных выше.
Нажмите «Начать новую игру», далее — «Создать армию».
Нажмите кнопку «Сгенерировать пресет», чтобы проверить, как работает реализованный вами метод generate.
Далее руками расставьте юниты армии игрока: выберите текущий юнит нажатием соответствующей кнопки, и разместите его, щёлкнув по обведённой красной линией части игрового поля.
Создав армии игрока и компьютера, нажмите кнопку «Создать армию» и вернитесь в меню запуска боя.
Нажмите кнопку «Начать бой». Запуск боя запустит ваш метод simulate, и вы сможете проверить его работу. На каждом ходу юнита вы можете проверить работу метода getSuitableUnits, если юнит смог найти цель для атаки, и getTargetPath, если юнит смог корректно дойти до цели атаки и атаковать её или пропустил ход
Описание библиотеки heroes_task_lib
Эта библиотека содержит основные классы и интерфейсы, необходимые как проекту игры, так и проекту задания студента.

В проекте библиотеки игры heroes_task_lib определено четыре интерфейса, методы которых вам предстоит имплементировать в проекте heroes_task согласно документации. Это интерфейсы GeneratePreset, SimulateBattle, SuitableForAttackUnitsFinder и UnitTargetPathFinder.

Данные интерфейсы отвечают за реализацию следующего логического функционала внутри основного проекта игры:

GeneratePreset содержит в себе метод Army generate(List<Unit> unitList, int maxPoints), который отвечает за генерацию пресета армии противника.
SimulateBattle содержит в себе метод void simulate(Army playerArmy, Army computerArmy) throws InterruptedException; и отвечает за осуществление симуляции боя.
SuitableForAttackUnitsFinder содержит в себе методList<Unit> getSuitableUnits(List<List<Unit>> unitsByRow, boolean isLeftArmyTarget); и отвечает за создание перечня подходящих для атаки юнитов.
UnitTargetPathFinder содержит в себе метод List<Edge> getTargetPath(Unit attackUnit, Unit targetUnit, List<Unit> existingUnitList); и отвечает за поиск наикратчайшего пути между атакующим и атакуемым юнитом.
Интерфейс PrintBattleLog содержит в себе метод void printBattleLog(Unit attackingUnit, Unit target); и отвечает за печать лога после каждого хода юнита. Его реализовывать не нужно — используйте его, передав в качестве параметров атакующий юнит и юнит-цель атаки.
Также библиотека содержит следующие классы, необходимые как для работы основной игры, так и для реализации имплементации интерфейсов, описанных выше в проекте heroes_task:

1. Класс Unit — содержит в себе основные характеристики юнита, такие как уникальное имя, тип, тип атаки, здоровье, базовая атака и стоимость.

Название поля	Тип поля	Описание поля
name	String	Уникальное имя юнита в рамках армии
unitType	String	Тип юнита: лучник, копейщик, мечник или всадник
health	int	Количество здоровья юнита
baseAttack	int	Количество урона, наносимое юнитом при атаке
cost	int	Стоимость юнита в очках
attackType	String	Тип атаки юнита: дистанционная или ближняя
program	Program	Программа поведения юнита при атаке
isAlive	boolean	Статус юнита: живой или мёртвый
2. Класс Army — содержит в себе список юнитов армии, а также суммарное количество очков юнитов данной армии.

Название поля	Тип поля	Описание поля
units	List<Units>	Список юнитов в армии
points	int	Суммарное количество очков юнитов в армии
3. Класс Program — содержит в себе общую часть логики программы поведения каждого юнита при атаке.

Название поля	Тип поля	Описание поля
unit	Unit	Ссылка на юнит, которому назначена программа
allyArmy	Army	Ссылка на армию союзников
enemyArmy	int	Ссылка на армию противника
simSpeed	int	Скорость симуляции боя
4. Класс Edge — фактически класс объекта пути, содержит в себе координаты x и y.

Название поля	Тип поля	Описание поля
x	int	Координата икс на игровом поле
y	int	Координата игрек на игровом поле
5. Класс EdgeDistance — класс объекта пути, который хранит в себе расстояние до стартовой точки.

Название поля	Тип поля	Описание поля
x	int	Координата икс на игровом поле
y	int	Координата игрек на игровом поле
distance	int	Расстояние в клетках от начальной точки до текущей точки координат
Далее — описание классов программы действия юнитов.

Вам следует использовать метод unit.getProgram().attack() каждого юнита для осуществления атаки юнитом армии компьютера или игрока. Все эти методы уже реализованы, каждому типу юнитов, с которым вы будете работать, уже назначена соответствующая программа.

Класс ComputerArcherProgram — класс с реализацией метода attack лучника армии компьютера.
Класс ComputerKnightProgram — класс с реализацией метода attack всадника армии компьютера.
Класс ComputerPikemanProgram — класс с реализацией метода attack копейщика армии компьютера.
Класс ComputerSwordsmanProgram — класс с реализацией метода attack мечника армии компьютера.
Класс UserArcherProgram — класс с реализацией метода attack лучника армии игрока.
Класс UserKnightProgram — класс с реализацией метода attack всадника армии игрока.
Класс UserPikemanProgram — класс с реализацией метода attack копейщика армии игрока.
Класс UserSwordsmanProgram — класс с реализацией метода attack мечника армии игрока.



Вы подошли к завершающему этапу — сдаче проекта. Это важная часть работы, которая позволяет получить обратную связь от ментора и добавить проект в портфолио.

Этапы сдачи проекта:
Размещение кода на GitHub
Загрузите свой код в репозиторий. Убедитесь, что структура понятна, — добавьте файл README.md с описанием:

какие алгоритмы вы реализовали;
как рассчитана их алгоритмическая сложность.
Убедитесь, что в репозитории также присутствует собранный JAR-файл вашего проекта.

Чтобы проверить ваше решение, поместите собранный jar вашего проекта с реализованными интерфейсами в папку heroes\jars, заменив лежащий там obf.jar. Он автоматически подхватится игрой при запуске, и она будет использовать реализацию ваших алгоритмов.

Подготовка к отправке проекта на проверку
Проверьте, что:

все функции проекта работают корректно и соответствуют ТЗ;
код оформлен и структурирован по стандартам;
в репозитории есть описание проекта и документация по каждому модулю;
если используются внешние библиотеки, добавлены инструкции по их установке.
Когда проект будет готов, отправьте ссылку на ваш репозиторий через форму сдачи. Ментор проверит работу и даст подробную обратную связь.

Критерии оценивания
Максимальная суммарная оценка за проект — 50 баллов. Оценивание разделено по категориям, соответствующим реализации ключевых частей задания. Ниже перечислены критерии с указанием достижений и баллов.
1. Генерация армии противника (метод generate) — до 15 баллов.

Метод корректно формирует армию согласно требованиям (состав юнитов не нарушает лимиты, суммарная стоимость не превышает maxPoints)	6 баллов
Выбран правильный алгоритмический подход для подбора оптимального состава (например, жадный алгоритм по коэффициенту «атаки/стоимость»)	1 балл
Предоставлено обоснование алгоритмической сложности решения для метода (расчёт и доказательство сложности)	3 балла
Достигнута требуемая сложность 	3 балла
Улучшена сложность по сравнению с базовой (решение работает быстрее, чем , при сохранении корректности)	2 балла
2. Симуляция боя (метод simulate) — до 10 баллов.

Полностью корректная реализация логики боя по раундам, очерёдность ходов соответствует заданной (сортировка по атаке, чередование ходов, удаление погибших, завершение боя)	4 балла
Алгоритм симуляции подробно протестирован и покрывает особые случаи (юниты без цели, разные количества раундов, одновременные смерти и прочее)	1 балл
Обоснован и рассчитан порядок сложности алгоритма симуляции	2 балла
Симуляция выполнена с требуемой или лучшей сложностью 	2 балла
Реализация выдерживает нагрузку (большое число юнитов) без деградации производительности	1 балл
3. Отбор целей для атаки (метод getSuitableUnits) — до 10 баллов.

Метод верно идентифицирует доступные для атаки цели в разных сценариях (атака игрока или компьютера, юниты в разных рядах)	4 балла
Учтены граничные случаи: отсутствие противников в ряду, все юниты прикрыты и тому подобное (метод возвращает пустой список, если целей нет)	1 балл
Представлен анализ сложности алгоритма отбора целей	2 балла
Достигнута сложность не хуже линейной (, где  — число юнитов в армии)	2 балла
Реализация эффективно интегрирована в общий процесс (не дублирует лишние вычисления, использует структуру данных оптимально)	1 балл
4. Поиск кратчайшего пути (метод getTargetPath) — до 15 баллов.

Метод находит корректный кратчайший путь на поле при различных расположениях юнитов-препятствий (или возвращает пустой список, если путь недоступен)	6 баллов
Использован эффективный алгоритм поиска пути в графе (A*, Дейкстра или аналогичный), корректно обработаны посещённые клетки, реализация не зацикливается	1 балл
Описана и вычислена трудоёмкость алгоритма поиска пути	3 балла
Достигнута сложность порядка  (близка к теоретически оптимальной для поиска пути на сетке)	3 балла
Решение превосходит базовые ожидания по скорости (например, за счёт удачной эвристики, уменьшения количества проверяемых узлов)